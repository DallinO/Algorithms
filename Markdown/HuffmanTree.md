# Huffman Tree - Algorithm Report

(c) BYU-Idaho - It is an honor code violation to post this file completed in a public file sharing site. S4.

Name: 

## 1. Code (60%)

Make sure that you submit both the HuffmanTree.cs file and this markdown file.

## 2. Methodology (20%)

NOTE: Do not copy/paste from an AI or the book.  Answer these questions in your own words without code.  You will either receive a grade of `Correct`, `More Detail Needed`, or `Incorrect` for each question.

1. Explain how text is profiled prior to creating huffman codes.

Profiling the text involves counting the frequency of each character in the text and storing these counts in a dictionary. This frequency profile is essential for building the Huffman tree since it determines the structure of the tree and the resulting Huffman codes, which are used for efficient encoding and decoding of the text.

2. Explain how huffman codes are created from the profile by using a priority queue to build a huffman tree.

The process begins with profiling the text to determine the frequency of each character. This frequency information is used to initialize the priority queue where each character is represented as a node with its frequency as the priority. Nodes with lower frequencies are given higher priority. The Huffman tree is then built by repeatedly removing the two nodes with the lowest frequencies from the priority queue and combining them into a new internal node whose frequency is the sum of its childrens frequencies. This new node is reinserted into the priority queue. This process continues until only one node remains which becoming the root. Finally Huffman codes are generated by traversing the tree from the root to each leaf node assigning binary codes based on the path taken. This method compresses data efficiently by using shorter codes for more frequent characters and longer codes for less frequent characters.

3. Explain how to decode a string of huffman codes (1's and 0's) using the huffman tree.

Start at the root of the Huffman tree and traverse it according to each bit in the encoded string. For each 0 move to the left child and for each 1 move to the right. When a leaf node is reached the character represented by that leaf is decoded, and you add it to the output string. Then, return to the root of the tree and repeat the process with the next sequence of bits. Continue this traversal until all bits in the encoded string have been processed and the entire decoded string is reconstructed. This method ensures that the encoded string is accurately converted back to the original text.

## 3. Performance (10%)

The performance for the encode and decode (where $n$ is the length of text to encode or decode)

* Encode:
    * Worst Case: $O(n)$
    * Best Case: $\Omega(n)$
* Decode:
    * Worst Case: $O(n)$
    * Best Case: $\Omega(n)$

## 4. AI Research (10%)

NOTE: Do not copy/paste from the AI.  Describe what you learned in at least 100 of your own words.

Using an AI, explore Adaptive Huffman Coding which can create encode data without creating a profile first.

Adaptive Huffman algorithms such as Faller-Gallager-Knuth and Vitter's Algorithm offer dynamic encoding capabilities by constructing the Huffman tree in real-time as data is processed. Unlike traditional Huffman coding, which requires a pre-existing frequency profile of the data, these adaptive methods adjust the tree dynamically based on incoming symbols. This adaptability is particularly advantageous for scenarios involving streaming data or data with unpredictable frequency distributions. By continuously updating the tree, the algorithms efficiently handle changes in data characteristics without the need for re-analyzing or re-encoding entire datasets. However, this dynamic behavior introduces complexity and potential overhead in maintaining and updating the tree structure in real-time applications, necessitating careful implementation for optimal performance.